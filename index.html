<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MastApp - Predictor de Orgasmo</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            background-color: #000;
            color: #fff;
            text-align: center;
            margin: 0;
            padding: 20px;
        }
        #video {
            width: 100%;
            max-width: 400px;
            border: 2px solid #fff;
            border-radius: 10px;
        }
        #gallery {
            display: none;
            margin-top: 20px;
        }
        .photo {
            width: 200px;
            height: 150px;
            background: #333;
            margin: 10px;
            display: inline-block;
            border-radius: 5px;
            overflow: hidden;
        }
        #status {
            margin-top: 20px;
            font-size: 18px;
        }
        #orgasmCountdown {
            display: none;
            font-size: 48px;
            color: #ff0000;
            margin: 10px;
            animation: pulse 1s infinite;
        }
        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }
        #dirtyTalk {
            margin-top: 10px;
            font-size: 14px;
            color: #ffcc00;
            font-style: italic;
        }
        button {
            background: #ff0000;
            color: #fff;
            border: none;
            padding: 10px 20px;
            font-size: 16px;
            border-radius: 5px;
            cursor: pointer;
            margin: 10px;
        }
        button:hover {
            background: #cc0000;
        }
        audio {
            display: none;
        }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/pose-detection@latest"></script>
    <script src="https://cdn.jsdelivr.net/npm/@nsfwjs/core@2.4.2/dist/index.min.js"></script>
</head>
<body>
    <h1>MastApp: Predictor de Orgasmo Activado</h1>
    <p>Local y privado. Acelera sostenido pa' trigger el clímax.</p>
    
    <video id="video" autoplay muted playsinline></video>
    <br>
    <button id="startBtn">Iniciar Cámara</button>
    <div id="status">Estado: Esperando...</div>
    <div id="orgasmCountdown"></div>
    <div id="dirtyTalk"></div>
    
    <div id="gallery">
        <h2>Fotos Dinámicas</h2>
        <div id="photos"></div>
    </div>

    <!-- Audios gemidos -->
    <audio id="moan1" preload="auto" loop><source src="moan1.mp3" type="audio/mpeg"></audio>
    <audio id="moan2" preload="auto" loop><source src="moan2.mp3" type="audio/mpeg"></audio>
    <audio id="moan3" preload="auto" loop><source src="moan3.mp3" type="audio/mpeg"></audio>

    <!-- Audios voiced dirty talk -->
    <audio id="dirty1" preload="auto"><source src="dirty1.mp3" type="audio/mpeg"></audio>
    <audio id="dirty2" preload="auto"><source src="dirty2.mp3" type="audio/mpeg"></audio>
    <audio id="dirty3" preload="auto"><source src="dirty3.mp3" type="audio/mpeg"></audio>
    <audio id="dirty4" preload="auto"><source src="dirty4.mp3" type="audio/mpeg"></audio>
    <audio id="dirty5" preload="auto"><source src="dirty5.mp3" type="audio/mpeg"></audio>

    <script>
        let video = document.getElementById('video');
        let status = document.getElementById('status');
        let orgasmCountdown = document.getElementById('orgasmCountdown');
        let dirtyTalkDiv = document.getElementById('dirtyTalk');
        let gallery = document.getElementById('gallery');
        let photosDiv = document.getElementById('photos');
        let detector;
        let nsfwModel;
        let isNaked = false;
        let penisDetected = false;
        let masturbationSpeed = 0;
        let strokeCount = 0;
        let currentMoanAudio = null;
        let currentDirtyAudio = null;
        let speechSynth = window.speechSynthesis;
        let lastDirtyTime = 0;

        // Nuevo: Predictor de orgasmo
        let speedHistory = []; // {time: Date.now(), speed: num}
        let orgasmMode = false;
        let countdownInterval;
        const ACCEL_THRESHOLD = 1.2; // 20% accel
        const HISTORY_SIZE = 10; // Últimos 10 samples
        const SAMPLE_INTERVAL = 1000; // ms por sample
        let lastSampleTime = 0;

        // Hand tracking
        let prevHandY = null;
        let handVelocity = 0;
        let direction = 0;
        let strokeThreshold = 20;

        // Frases para orgasmo (hardcore)
        const climaxPhrases = [
            '¡Estás cerca, no pares!',
            '¡Ya viene el clímax, acelera!',
            '¡Siente cómo sube, papi!',
            '¡Uno más y explotas!'
        ];

        const dirtyPhrases = {
            low: ['Eres tan sexy...', 'Me excito viéndote.'],
            medium: ['Me estoy tocando por ti.', 'Ven y hazme tuya.'],
            high: ['¡Fóllame ya!', 'Más fuerte, no pares.']
        };

        const moanAudios = [
            document.getElementById('moan1'),
            document.getElementById('moan2'),
            document.getElementById('moan3'),
        ];

        const dirtyAudios = [
            document.getElementById('dirty1'),
            document.getElementById('dirty2'),
            document.getElementById('dirty3'),
            document.getElementById('dirty4'),
            document.getElementById('dirty5'),
        ].filter(audio => audio.src);

        function initAudio() {
            moanAudios.forEach(audio => { audio.volume = 0; audio.playbackRate = 0.8; });
            dirtyAudios.forEach(audio => { audio.volume = 0; audio.playbackRate = 0.8; });
        }

        function vibrateWithSpeed(speed) {
            if (!navigator.vibrate) return;
            const intensity = Math.floor(speed * 50);
            navigator.vibrate([100, intensity]);
        }

        // Trigger predictor: countdown con escalada
        function triggerOrgasmPredictor() {
            if (orgasmMode) return;
            orgasmMode = true;
            status.textContent += ' | ¡Clímax inminente!';
            let countdown = 10;
            orgasmCountdown.style.display = 'block';
            countdownInterval = setInterval(() => {
                orgasmCountdown.textContent = countdown;
                if (countdown <= 5) {
                    // Escalada: max audio/vibe
                    if (currentMoanAudio) {
                        currentMoanAudio.volume = 1.0;
                        currentMoanAudio.playbackRate = 2.0;
                    }
                    navigator.vibrate(200); // Full vibe
                    sayDirtyTalk(10); // Max speed pa' hardcore phrase
                }
                if (countdown <= 0) {
                    clearInterval(countdownInterval);
                    orgasmCountdown.style.display = 'none';
                    orgasmMode = false;
                    // Post-clímax: reset
                    speedHistory = [];
                    strokeCount = 0;
                    status.textContent = '¡Explosión! Reset pa\' próxima.';
                }
                countdown -= 1;
            }, 1000);
        }

        function sayDirtyTalk(speed) {
            const now = Date.now();
            if (now - lastDirtyTime < 5000 || (currentDirtyAudio && !currentDirtyAudio.ended)) return;
            lastDirtyTime = now;

            let phrases = orgasmMode ? climaxPhrases : (speed <= 3 ? dirtyPhrases.low : speed <= 7 ? dirtyPhrases.medium : dirtyPhrases.high);

            if (dirtyAudios.length > 0 && !currentDirtyAudio) {
                currentDirtyAudio = dirtyAudios[Math.floor(Math.random() * dirtyAudios.length)];
                const volume = 0.7 + (speed / 10) * 0.2;
                const rate = 0.9 + (speed / 10) * 0.3;
                currentDirtyAudio.volume = volume;
                currentDirtyAudio.playbackRate = rate;
                currentDirtyAudio.play().then(() => {
                    dirtyTalkDiv.textContent = '[Voz: Dirty Talk]';
                }).catch(err => {
                    console.log('Error voiced:', err);
                    fallbackTTS(phrases[Math.floor(Math.random() * phrases.length)], speed);
                });
                currentDirtyAudio.onended = () => { currentDirtyAudio = null; dirtyTalkDiv.textContent = ''; };
            } else {
                const phrase = phrases[Math.floor(Math.random() * phrases.length)];
                const utterance = new SpeechSynthesisUtterance(phrase);
                utterance.lang = 'es-ES';
                utterance.pitch = 1.2 + (speed / 10) * 0.5;
                utterance.rate = 0.9 + (speed / 10) * 0.3;
                utterance.volume = 0.7 + (speed / 10) * 0.2;
                utterance.onend = () => { dirtyTalkDiv.textContent = ''; };
                speechSynth.speak(utterance);
                dirtyTalkDiv.textContent = phrase;
            }
        }

        function fallbackTTS(phrase, speed) {
            const utterance = new SpeechSynthesisUtterance(phrase);
            utterance.lang = 'es-ES';
            utterance.pitch = 1.2 + (speed / 10) * 0.5;
            utterance.rate = 0.9 + (speed / 10) * 0.3;
            utterance.volume = 0.7 + (speed / 10) * 0.2;
            utterance.onend = () => { dirtyTalkDiv.textContent = ''; };
            speechSynth.speak(utterance);
            dirtyTalkDiv.textContent = phrase;
        }

        function playMoan(speed) {
            if (currentMoanAudio) {
                currentMoanAudio.pause();
                currentMoanAudio.currentTime = 0;
            }
            currentMoanAudio = moanAudios[Math.floor(Math.random() * moanAudios.length)];
            if (currentMoanAudio) {
                const volume = Math.min(0.8, (speed / 10) * 0.8);
                const rate = 0.8 + (speed / 10) * 1.2;
                currentMoanAudio.volume = volume;
                currentMoanAudio.playbackRate = rate;
                currentMoanAudio.play().catch(err => console.log('Error moan:', err));
            }
        }

        async function detectNudity(poses) {
            if (poses.length === 0) return false;
            const keypoints = poses[0].keypoints;
            const leftShoulder = keypoints.find(kp => kp.name === 'left_shoulder');
            const rightShoulder = keypoints.find(kp => kp.name === 'right_shoulder');
            const leftHip = keypoints.find(kp => kp.name === 'left_hip');
            const rightHip = keypoints.find(kp => kp.name === 'right_hip');
            if (leftShoulder?.score > 0.5 && rightShoulder?.score > 0.5 && leftHip?.score > 0.5 && rightHip?.score > 0.5) {
                const torsoLength = Math.abs(leftHip.y - leftShoulder.y);
                return torsoLength > 100;
            }
            return false;
        }

        async function detectPenis(poses, canvas) {
            if (!nsfwModel || poses.length === 0) return false;
            const keypoints = poses[0].keypoints;
            const leftHip = keypoints.find(kp => kp.name === 'left_hip');
            const rightHip = keypoints.find(kp => kp.name === 'right_hip');
            if (!leftHip || !rightHip || leftHip.score < 0.7 || rightHip.score < 0.7) return false;

            const x = Math.min(leftHip.x, rightHip.x) - 50;
            const y = Math.max(leftHip.y, rightHip.y) - 100;
            const width = Math.abs(leftHip.x - rightHip.x) + 100;
            const height = 150;
            const croppedCanvas = document.createElement('canvas');
            croppedCanvas.width = width;
            croppedCanvas.height = height;
            const ctx = croppedCanvas.getContext('2d');
            ctx.drawImage(canvas, x, y, width, height, 0, 0, width, height);

            const predictions = await nsfwModel.classify(croppedCanvas);
            const pornScore = predictions.find(p => p.className === 'Porn')?.probability || 0;
            return pornScore > 0.7;
        }

        // Upgradado con predictor
        let frameCount = 0;
        function detectSpeedAndStrokes(poses) {
            frameCount++;
            if (frameCount % 5 !== 0) return masturbationSpeed;
            if (poses.length === 0) {
                prevHandY = null;
                if (Date.now() - lastSampleTime > 5000) { // Reset si parado >5s
                    speedHistory = [];
                    orgasmMode = false;
                    if (countdownInterval) clearInterval(countdownInterval);
                    orgasmCountdown.style.display = 'none';
                }
                return 0;
            }
            const rightWrist = poses[0].keypoints.find(kp => kp.name === 'right_wrist');
            if (!rightWrist || rightWrist.score < 0.6) {
                prevHandY = null;
                return 0;
            }

            const currentY = rightWrist.y;
            if (prevHandY === null) {
                prevHandY = currentY;
                return 0;
            }

            const deltaY = currentY - prevHandY;
            handVelocity = Math.abs(deltaY);
            masturbationSpeed = Math.min(10, handVelocity * 10);

            // Stroke count
            const newDirection = deltaY > 0 ? -1 : 1;
            if (direction !== 0 && direction !== newDirection && handVelocity > strokeThreshold) {
                strokeCount++;
            }
            direction = newDirection;
            prevHandY = currentY;

            // Sample pa' history cada seg
            const now = Date.now();
            if (now - lastSampleTime >= SAMPLE_INTERVAL) {
                speedHistory.push({time: now, speed: masturbationSpeed});
                if (speedHistory.length > HISTORY_SIZE) speedHistory.shift();
                lastSampleTime = now;

                // Chequea aceleración
                if (speedHistory.length >= 5 && masturbationSpeed > 2) {
                    const recentAvg = speedHistory.slice(-5).reduce((sum, s) => sum + s.speed, 0) / 5;
                    const prevAvg = speedHistory.slice(0, -5).reduce((sum, s) => sum + s.speed, 0) / (speedHistory.length - 5) || 1;
                    if (recentAvg > prevAvg * ACCEL_THRESHOLD) {
                        triggerOrgasmPredictor();
                    }
                }
            }

            return masturbationSpeed;
        }

        async function showRandomPhotos() {
            photosDiv.innerHTML = '';
            try {
                for (let i = 0; i < 3; i++) {
                    const res = await fetch(`https://api.unsplash.com/photos/random?query=abstract&client_id=YOUR_UNSPLASH_KEY`);
                    const data = await res.json();
                    const img = document.createElement('div');
                    img.className = 'photo';
                    img.style.backgroundImage = `url(${data.urls.small})`;
                    img.style.backgroundSize = 'cover';
                    photosDiv.appendChild(img);
                }
            } catch (err) {
                console.log('Fetch error:', err);
                const fallbackUrls = ['https://via.placeholder.com/200x150/ff0000/ffffff?text=Hot+1', 'https://via.placeholder.com/200x150/ff6600/ffffff?text=Hot+2', 'https://via.placeholder.com/200x150/ff9900/ffffff?text=Hot+3'];
                fallbackUrls.forEach(url => {
                    const img = document.createElement('div');
                    img.className = 'photo';
                    img.style.backgroundImage = `url(${url})`;
                    img.style.backgroundSize = 'cover';
                    photosDiv.appendChild(img);
                });
            }
            gallery.style.display = 'block';
        }

        async function detectLoop() {
            if (detector && video.readyState === 4) {
                const canvas = document.createElement('canvas');
                canvas.width = video.videoWidth;
                canvas.height = video.videoHeight;
                canvas.getContext('2d').drawImage(video, 0, 0);
                const poses = await detector.estimatePoses(video);
                isNaked = await detectNudity(poses);
                penisDetected = await detectPenis(poses, canvas);
                const speed = detectSpeedAndStrokes(poses);

                if (isNaked) {
                    status.textContent = `Desnudo on. Movs: ${strokeCount} | Speed: ${speed.toFixed(1)}`;
                    showRandomPhotos();
                } else {
                    status.textContent = 'No desnudo aún...';
                    gallery.style.display = 'none';
                    strokeCount = 0;
                }

                if (penisDetected && isNaked) {
                    status.textContent += ' | Pene on.';
                    playMoan(speed);
                    vibrateWithSpeed(speed);
                    if (speed > 2 && !orgasmMode) sayDirtyTalk(speed);
                } else {
                    if (currentMoanAudio) {
                        currentMoanAudio.pause();
                        currentMoanAudio.currentTime = 0;
                    }
                    if (currentDirtyAudio) {
                        currentDirtyAudio.pause();
                        currentDirtyAudio.currentTime = 0;
                        currentDirtyAudio = null;
                    }
                    dirtyTalkDiv.textContent = '';
                }

                requestAnimationFrame(detectLoop);
            }
        }

        document.getElementById('startBtn').addEventListener('click', async () => {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'user' } });
                video.srcObject = stream;
                initAudio();
                detector = await poseDetection.createDetector(poseDetection.SupportedModels.MoveNet);
                nsfwModel = await nsfwjs.load();
                status.textContent = 'Cámara up. Acelera pa\' predictor.';
                detectLoop();
            } catch (err) {
                status.textContent = 'Error: ' + err.message;
            }
        });

        console.log('Predictor listo. ¡Siente la predicción, carnal!');
    </script>
</body>
</html>