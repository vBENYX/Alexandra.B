<script>
    let matriculaActual = "";
    let registroDuplicado = null; 
    let modalCallback = (result) => {}; // Callback para el modal
    let historialFiltro = null; // null = ver todo

    // --- FUNCIONES DE ALMACENAMIENTO (LOCALSTORAGE) ---
    function guardarRegistros(registros) {
        localStorage.setItem('registrosMatriculas', JSON.stringify(registros));
    }
    
    function cargarRegistros() {
        return JSON.parse(localStorage.getItem('registrosMatriculas') || '[]');
    }
    
    function limpiarTodosLosRegistros() {
        localStorage.removeItem('registrosMatriculas');
        actualizarContadores();
        actualizarHistorialReciente();
        mostrarConfirmacion("Todos los registros eliminados.", "fas fa-trash-alt");
    }

    // --- GESTIÓN DE PANTALLAS (TRANSICIÓN DE DESVANECIMIENTO) ---
    function mostrarPaso(pasoId) {
        const currentActive = document.querySelector('.step-content.active');
        const targetPaso = document.getElementById(pasoId);
        
        document.getElementById('advertenciaDuplicado').style.display = 'none';
        
        if (currentActive && currentActive.id === targetPaso.id) return;

        if (currentActive) {
            currentActive.classList.remove('active');
            currentActive.style.opacity = 0;
            currentActive.style.transform = 'scale(0.98)';
            
            setTimeout(() => { 
                currentActive.style.display = 'none'; 
                currentActive.style.position = 'absolute'; 

                targetPaso.style.display = 'block';
                targetPaso.style.position = 'relative'; 

                setTimeout(() => {
                    targetPaso.classList.add('active');
                    targetPaso.style.opacity = 1;
                    targetPaso.style.transform = 'scale(1)';
                }, 50); 
            }, 350); 
        } else {
            targetPaso.style.display = 'block';
            targetPaso.style.position = 'relative';
            setTimeout(() => {
                targetPaso.classList.add('active');
                targetPaso.style.opacity = 1;
                targetPaso.style.transform = 'scale(1)';
            }, 50);
        }
    }

    function mostrarPaso1(isBackward = false) {
        mostrarPaso('paso1'); 
        matriculaActual = "";
        registroDuplicado = null;
        document.getElementById('matriculaInput').value = '';
        document.getElementById('descCargada').value = '';
        document.getElementById('descAveriada').value = '';
        document.getElementById('matriculaInput').focus();
    }
    
    // --- LÓGICA CLAVE: REGISTRO/ESTADO Y ALERTA INTELIGENTE ---
    
    function registrarMatricula() {
        matriculaActual = document.getElementById('matriculaInput').value.toUpperCase().trim();
        if (!matriculaActual) {
            mostrarConfirmacion("Ingrese la matrícula.", "fas fa-exclamation-triangle");
            return;
        }
        
        const registros = cargarRegistros();
        const existente = registros.find(reg => reg.matricula === matriculaActual);
        registroDuplicado = existente;

        // ** LÓGICA DE INTELIGENCIA: ALERTA PROACTIVA DE AVERÍA **
        if (existente && existente.estado === 'Averiada') {
            abrirModal(
                '¡Alerta de Avería!',
                `<i class="fas fa-exclamation-triangle" style="color:var(--ios-red); margin-right:5px;"></i> La matrícula <strong>${matriculaActual}</strong> estaba registrada como **AVERIADA**. ¿Confirma que ha sido reparada y está lista para ser asignada a Carga o Vacía?`,
                'Confirmar Reparación',
                'btn-modal-confirm-blue',
                () => {
                    // Si confirma la reparación, procedemos a Paso 2 normalmente
                    procederAPaso2();
                }
            );
        } else {
            // Si no hay avería previa o es un registro nuevo, procedemos directamente
            procederAPaso2();
        }
    }

    function procederAPaso2() {
        mostrarPaso('paso2'); 
        document.getElementById('mostrarMatricula').textContent = matriculaActual;
        document.getElementById('cargadaDetalles').style.display = 'none';
        document.getElementById('averiadaDetalles').style.display = 'none';
        
        // Resetear botones
        document.querySelectorAll('#botonesEstado button').forEach(btn => btn.classList.remove('btn-state-active'));

        if (registroDuplicado) {
            const advertenciaDiv = document.getElementById('advertenciaDuplicado');
            document.getElementById('estadoAnterior').textContent = registroDuplicado.estado;
            advertenciaDiv.style.display = 'block';
            
            // Pre-seleccionar el estado anterior para la UX
            const btnId = registroDuplicado.estado === 'Cargada' ? 'btnCargada' : 
                          registroDuplicado.estado === 'Vacía' ? 'btnVacia' : 
                          registroDuplicado.estado === 'Averiada' ? 'btnAveriadaState' : null;
            
            if (btnId) manejarEstado(btnId.replace('btn', '').toLowerCase().replace('state', ''), true); // 'true' para forzar la selección sin guardar
            
        } else {
            document.getElementById('advertenciaDuplicado').style.display = 'none';
        }
    }


    function manejarEstado(estado, isAutoSelect = false) {
        document.getElementById('cargadaDetalles').style.display = 'none';
        document.getElementById('averiadaDetalles').style.display = 'none';

        // Activar el botón visualmente
        document.querySelectorAll('#botonesEstado button').forEach(btn => btn.classList.remove('btn-state-active'));
        let activeBtnId = '';
        
        if (estado === 'cargada') {
            document.getElementById('cargadaDetalles').style.display = 'block';
            document.getElementById('descCargada').focus();
            document.getElementById('descCargada').value = (registroDuplicado && registroDuplicado.estado === 'Cargada') ? registroDuplicado.descripcion : '';
            activeBtnId = 'btnCargada';
        } else if (estado === 'averiada') {
            document.getElementById('averiadaDetalles').style.display = 'block';
            document.getElementById('descAveriada').focus();
            document.getElementById('descAveriada').value = (registroDuplicado && registroDuplicado.estado === 'Averiada') ? registroDuplicado.descripcion : '';
            activeBtnId = 'btnAveriadaState';
        } else if (estado === 'vacia') { 
            activeBtnId = 'btnVacia';
            if (!isAutoSelect) {
                // Si no es una autoselección (es decir, el usuario hizo click), guardamos directamente Vacía.
                guardarRegistro('vacia', 'Lista para cargar');
            }
        }
        
        if (activeBtnId) {
            document.getElementById(activeBtnId).classList.add('btn-state-active');
        }
    }
    
    function microInteraccionBoton(buttonElement, estado) {
        const originalText = buttonElement.innerHTML;
        buttonElement.disabled = true; 
        
        let confirmText = '';
        let confirmClass = '';
        
        if (estado === 'Cargada') {
            confirmText = '<i class="fas fa-check"></i> ¡Guardado!';
            confirmClass = 'btn-confirm-cargada';
        } else if (estado === 'Vacía') {
            confirmText = '<i class="fas fa-check"></i> ¡Guardado!';
            confirmClass = 'btn-confirm-vacia';
        } else if (estado === 'Averiada') {
            confirmText = '<i class="fas fa-times-circle"></i> ¡Guardado!';
            confirmClass = 'btn-confirm-averiada';
        }

        // Aplicar feedback
        buttonElement.innerHTML = confirmText;
        buttonElement.classList.add(confirmClass);
        
        // ** NOTA: La animación Siri Wave se gestiona puramente por CSS y no necesita ser manipulada aquí, evitando el efecto de "bloqueo". **

        setTimeout(() => {
            // Restaurar estado
            buttonElement.innerHTML = originalText;
            buttonElement.classList.remove(confirmClass);
            buttonElement.disabled = false; 
            
            mostrarConfirmacion(`¡${matriculaActual} registrado!`);
            mostrarPaso1(true); 
        }, 800); 
    }


    function guardarRegistro(estado, descripcionManual = '') {
        let descripcion = descripcionManual;
        let btnElement = null;
        let estadoDisplay = '';

        if (estado === 'cargada') {
            descripcion = document.getElementById('descCargada').value;
            btnElement = document.getElementById('btnGuardarCargada');
            estadoDisplay = 'Cargada'; 
        } else if (estado === 'averiada') {
            descripcion = document.getElementById('descAveriada').value;
            btnElement = document.getElementById('btnGuardarAveriada');
            estadoDisplay = 'Averiada'; 
        } else if (estado === 'vacia') {
             descripcion = 'Lista para cargar';
             btnElement = document.getElementById('btnVacia');
             estadoDisplay = 'Vacía'; 
        }

        if ((estadoDisplay === 'Cargada' || estadoDisplay === 'Averiada') && !descripcion.trim()) {
            mostrarConfirmacion(`Necesita una descripción para ${estadoDisplay}.`, "fas fa-exclamation-triangle");
            return;
        }

        const nuevoRegistro = {
            matricula: matriculaActual,
            estado: estadoDisplay,
            descripcion: descripcion.trim() || 'N/A',
            timestamp: new Date().getTime() 
        };

        let registros = cargarRegistros();
        const index = registros.findIndex(reg => reg.matricula === matriculaActual);

        if (index !== -1) {
            registros[index] = nuevoRegistro; // Reemplazar registro existente
        } else {
            registros.push(nuevoRegistro); // Añadir nuevo registro
        }

        guardarRegistros(registros);
        actualizarContadores();
        actualizarHistorialReciente();

        if (btnElement) {
            // Animación y transición visual
            microInteraccionBoton(btnElement, estadoDisplay);
        } else if (estado === 'vacia') {
             // Ya que el botón Vacia no tiene un botón de 'Guardar' aparte
             microInteraccionBoton(document.getElementById('btnVacia'), estadoDisplay);
        }
    }

    // --- MANEJO DE LA INTERFAZ DE USUARIO (Contadores e Historial) ---
    function actualizarContadores() {
        const registros = cargarRegistros();
        let counts = { Cargada: 0, Vacía: 0, Averiada: 0, Total: registros.length };

        registros.forEach(reg => {
            if (reg.estado === 'Cargada') counts.Cargada++;
            else if (reg.estado === 'Vacía') counts.Vacía++; 
            else if (reg.estado === 'Averiada') counts.Averiada++;
        });
        
        counts.Disponible = counts.Vacía; 

        const totalFlota = counts.Total;
        
        document.getElementById('countTotal').textContent = counts.Total;
        document.getElementById('countCargada').textContent = counts.Cargada;
        document.getElementById('countDisponible').textContent = counts.Vacía; 
        document.getElementById('countAveriada').textContent = counts.Averiada;

        // CORRECCIÓN: Se actualiza la función para interpolar correctamente la variable 'state'
        const updateCompactCard = (state, count) => {
            const percentValue = totalFlota > 0 ? Math.round((count / totalFlota) * 100) : 0;
            // FIX: Se usa la interpolación de template literal
            const percentText = `${percentValue}%`;
            
            // FIX: Se usa la interpolación para el ID correcto
            const percentElement = document.getElementById(`percent${state}`);
            if(percentElement) percentElement.textContent = percentText;
            
            // AJUSTE: Altura del relleno de fondo
            // FIX: Se usa la interpolación para el ID correcto
            const fillElement = document.getElementById(`fill${state}`);
            // FIX: La altura se basa en el porcentaje
            if(fillElement) fillElement.style.height = percentText;
        };
        
        updateCompactCard('Cargada', counts.Cargada);
        updateCompactCard('Disponible', counts.Vacía); 
        updateCompactCard('Averiada', counts.Averiada);
        
        // Animación de aparición de tarjetas
        const cardIds = ['cardTotal', 'cardCargada', 'cardDisponible', 'cardAveriada'];
        cardIds.forEach((id, index) => {
            const item = document.getElementById(id);
            if (!item.classList.contains('visible')) {
                setTimeout(() => {
                    item.classList.add('visible');
                }, 50 + index * 50); 
            }
        });
    }

    function filtrarHistorial(estado) {
        historialFiltro = estado;
        
        // Activar el botón de filtro correcto
        document.querySelectorAll('.filter-buttons button').forEach(btn => btn.classList.remove('filter-active'));
        if (estado === 'Cargada') {
            document.getElementById('btnFilterCargada').classList.add('filter-active');
        } else if (estado === 'Vacía') {
            document.getElementById('btnFilterVacia').classList.add('filter-active');
        } else if (estado === 'Averiada') {
            document.getElementById('btnFilterAveriada').classList.add('filter-active');
        } else {
            document.getElementById('btnFilterAll').classList.add('filter-active');
        }
        
        actualizarHistorialReciente();
    }

    function actualizarHistorialReciente() {
        let registros = cargarRegistros();
        const ul = document.getElementById('historialReciente');
        ul.innerHTML = ''; 

        // 1. Filtrar si es necesario
        if (historialFiltro) {
            registros = registros.filter(reg => reg.estado === historialFiltro);
        }
        
        if (registros.length === 0) {
            let message = 'Aún no hay movimientos registrados.';
            if (historialFiltro) {
                message = `No hay matrículas registradas como "${historialFiltro}".`;
            }
            ul.innerHTML = `<li style="justify-content:center; color: var(--text-light-gray); border-bottom: none;">${message}</li>`;
            return;
        }

        // 2. Ordenar por timestamp (más reciente primero)
        registros.sort((a, b) => b.timestamp - a.timestamp);
        
        // Mostrar solo los 5 más recientes del conjunto filtrado
        // CORRECCIÓN: Se actualiza para mostrar 5 si el filtro es 'Todo', o todos los filtrados
        const ultimosRegistros = historialFiltro === null ? registros.slice(0, 5) : registros; 
        
        ultimosRegistros.forEach(reg => {
            const dateObj = new Date(reg.timestamp);
            const hora = dateObj.toLocaleTimeString('es-ES', { hour: '2-digit', minute: '2-digit' });

            const estadoDisplay = reg.estado;
            const estadoClass = `estado-${estadoDisplay}`;
            
            const li = document.createElement('li');
            li.innerHTML = `
                <span class="status-indicator ${estadoDisplay}"></span>
                <span class="historial-matricula">${reg.matricula}</span>
                <span class="historial-estado ${estadoClass}">${estadoDisplay}</span>
                <span class="historial-time">${hora}</span>
            `;
            ul.appendChild(li);
        });
    }
    
    // --- MODAL CENTRALIZADO ---
    
    function abrirModal(title, message, confirmText, confirmClass, callback) {
        document.getElementById('modalTitle').textContent = title;
        document.getElementById('modalMessage').innerHTML = message;
        document.getElementById('modalConfirmButton').textContent = confirmText;
        document.getElementById('modalConfirmButton').className = `btn-modal-confirm ${confirmClass}`;
        modalCallback = (result) => {
            cerrarModal();
            if (result) callback();
        };
        document.getElementById('confirmModal').classList.add('open');
    }
    
    function cerrarModal(event) {
        const modal = document.getElementById('confirmModal');
        // Asegurarse de que solo se cierra al tocar el overlay directamente, no el contenido.
        if (!event || event.target === modal) {
            modal.classList.remove('open');
        }
    }

    function mostrarModalConfirmacionLimpiar() {
        abrirModal(
            '¡Eliminar Todos!',
            'Esta acción **eliminará permanentemente** todos los registros guardados en tu dispositivo. ¿Estás seguro de continuar?',
            'Sí, Eliminar Todo',
            'btn-modal-confirm-red',
            limpiarTodosLosRegistros 
        );
    }

    function mostrarConfirmacion(mensaje, icono = "fas fa-check-circle") {
        console.log(`[Notificación] ${mensaje}`);
        // Aquí podríamos disparar un toast o un modal de notificación si fuera una app completa.
    }
    
    // --- EXPORTACIÓN PDF (Mismo código que antes, solo actualizado) ---
    function hexToRgb(hex) {
        let shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
        hex = hex.replace(shorthandRegex, function(m, r, g, b) {
            return r + r + g + g + b + b;
        });
        let result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
        return result ? [
            parseInt(result[1], 16),
            parseInt(result[2], 16),
            parseInt(result[3], 16)
        ] : [0, 0, 0];
    }
    
    function exportarPDF() {
        const registros = cargarRegistros();

        if (typeof window.jspdf === 'undefined' || typeof window.jspdf.jsPDF === 'undefined' || !window.jspdf.jsPDF.API.autoTable) {
            mostrarConfirmacion("Error: El generador de PDF (jsPDF) no se ha cargado completamente. Inténtalo de nuevo.", "fas fa-exclamation-triangle");
            console.error("jsPDF object:", window.jspdf);
            return;
        }

        if (registros.length === 0) {
            mostrarConfirmacion("No hay registros para exportar.", "fas fa-info-circle");
            return;
        }

        try {
           const { jsPDF } = window.jspdf;
            const doc = new jsPDF('p', 'mm', 'a4');
            const margin = 10;
            let yPos = margin;
            const pageWidth = doc.internal.pageSize.width;
            
            // --- 1. CONFIGURACIÓN DE COLORES TIPO APPLE ---
            const APPLE_COLORS = {
                RED_XPO: hexToRgb('#FF3B30'),
                DARK_TEXT: hexToRgb('#1C1C1E'),
                MEDIUM_GRAY: hexToRgb('#D1D1D6'),
                GREEN_CARGADA: hexToRgb('#34C759'),
                YELLOW_VACIA: hexToRgb('#FFCC00'),
                HEADER_FILL: [255, 255, 255] 
            };
            
            // --- 2. PREPARACIÓN DE DATOS Y CONTEOS ---
            const registrosCargadas = registros
                .filter(reg => reg.estado === 'Cargada')
                .map(reg => [reg.matricula, reg.descripcion]); 
            
            const registrosVacías = registros
                .filter(reg => reg.estado === 'Vacía')
                .map(reg => [reg.matricula, reg.descripcion || 'Lista para cargar']); 
            
            const registrosAveriadas = registros
                .filter(reg => reg.estado === 'Averiada')
                .map(reg => [reg.matricula, reg.descripcion]);
                
            const counts = {
                    Cargada: registrosCargadas.length,
                    Vacía: registrosVacías.length,
                    Averiada: registrosAveriadas.length,
                    Total: registros.length
                };
            
            // --- 3. IMPLEMENTAR ENCABEZADO Y LOGO (Diseño Tipográfico Simple) ---
            const headerCardHeight = 25;
            const headerCardY = yPos;
            const headerCardX = margin;
            const headerCardWidth = pageWidth - 2 * margin;
            
            doc.setFillColor(APPLE_COLORS.HEADER_FILL[0], APPLE_COLORS.HEADER_FILL[1], APPLE_COLORS.HEADER_FILL[2]);
            doc.setDrawColor(APPLE_COLORS.MEDIUM_GRAY[0], APPLE_COLORS.MEDIUM_GRAY[1], APPLE_COLORS.MEDIUM_GRAY[2]);
            doc.setGState(new doc.GState({ opacity: 0.9 })); 
            doc.roundedRect(headerCardX, headerCardY, headerCardWidth, headerCardHeight, 3, 3, 'FD'); 
            doc.setGState(new doc.GState({ opacity: 1 })); 
            
            const logoY = headerCardY + headerCardHeight / 2;
            doc.setFont("helvetica", "bold");
            
            doc.setFontSize(18);
            const codeText = "CODE";
            const codeWidth = doc.getStringUnitWidth(codeText) * doc.getFontSize() / doc.internal.scaleFactor;
            
            doc.setFontSize(18);
            const xpoText = "XPO";
            const xpoWidth = doc.getStringUnitWidth(xpoText) * doc.getFontSize() / doc.internal.scaleFactor;
            
            const gap = 3; 
            const totalWidth = codeWidth + xpoWidth + gap;
            
            const codeStartX = (pageWidth / 2) - (totalWidth / 2);
            const xpoStartX = codeStartX + codeWidth + gap;
            
            doc.setTextColor(APPLE_COLORS.DARK_TEXT[0], APPLE_COLORS.DARK_TEXT[1], APPLE_COLORS.DARK_TEXT[2]);
            doc.text(codeText, codeStartX, logoY, { align: 'left', baseline: 'middle' });
            
            doc.setTextColor(APPLE_COLORS.RED_XPO[0], APPLE_COLORS.RED_XPO[1], APPLE_COLORS.RED_XPO[2]);
            doc.text(xpoText, xpoStartX, logoY, { align: 'left', baseline: 'middle' });
            
            yPos = headerCardY + headerCardHeight + margin; 
            
            // --- 4. IMPLEMENTAR BADGES SEMITRANSPARENTES DE RESUMEN ---
            
            const badgeHeight = 10; 
            const badgeMargin = 5;
            const badgeWidth = (pageWidth - 2 * margin - 2 * badgeMargin) / 3;
            const badgeY = yPos;
            
            const badges = [
                { label: 'CARGADAS', count: counts.Cargada, color: APPLE_COLORS.GREEN_CARGADA, x: margin, stateKey: 'Cargada' },
                { label: 'VACÍAS', count: counts.Vacía, color: APPLE_COLORS.YELLOW_VACIA, x: margin + badgeWidth + badgeMargin, stateKey: 'Vacía' },
                { label: 'AVERIADAS', count: counts.Averiada, color: APPLE_COLORS.RED_XPO, x: margin + 2 * (badgeWidth + badgeMargin), stateKey: 'Averiada' }
            ];

            doc.setFontSize(10);
            doc.setFont("helvetica", "bold");
            
            badges.forEach(badge => {
                const percentage = counts.Total > 0 ? (badge.count / counts.Total) : 0;
                const fillWidth = badgeWidth * percentage;
                
                doc.setFillColor(255, 255, 255);
                doc.setDrawColor(APPLE_COLORS.MEDIUM_GRAY[0], APPLE_COLORS.MEDIUM_GRAY[1], APPLE_COLORS.MEDIUM_GRAY[2]);
                doc.setGState(new doc.GState({ opacity: 0.9 }));
                doc.roundedRect(badge.x, badgeY, badgeWidth, badgeHeight, 1.5, 1.5, 'FD'); 
                doc.setGState(new doc.GState({ opacity: 1 }));
                
                doc.setFillColor(badge.color[0], badge.color[1], badge.color[2]);
                doc.setGState(new doc.GState({ opacity: 0.2 }));
                doc.roundedRect(badge.x, badgeY, fillWidth, badgeHeight, 1.5, 1.5, 'F'); 
                doc.setGState(new doc.GState({ opacity: 1 }));
                
                doc.setFontSize(6);
                doc.setFont("helvetica", "normal");
                doc.setTextColor(APPLE_COLORS.DARK_TEXT[0], APPLE_COLORS.DARK_TEXT[1], APPLE_COLORS.DARK_TEXT[2]);
                doc.text(badge.label, badge.x + badgeWidth / 2, badgeY + 3.5, { align: 'center' });

                doc.setFontSize(9);
                doc.setFont("helvetica", "bold");
                doc.setTextColor(badge.color[0], badge.color[1], badge.color[2]);
                // CORRECCIÓN: Se agrega la etiqueta y se interpola el porcentaje
                doc.text(`${badge.count} (${(percentage * 100).toFixed(0)}%)`, badge.x + badgeWidth / 2, badgeY + badgeHeight - 3.5, { align: 'center' });
            });
            
            yPos = badgeY + badgeHeight + 15; 

            // --- 5. APLICAR DISEÑO DE TABLAS ---
            
            const tableMarginX = 5; 
            const halfWidth = (pageWidth - 2 * margin - tableMarginX) / 2;
            let startYDoubleColumn = yPos;
            
            // Títulos de Sección
            doc.setFontSize(12);
            doc.setFont("helvetica", "bold");
            doc.setTextColor(APPLE_COLORS.DARK_TEXT[0], APPLE_COLORS.DARK_TEXT[1], APPLE_COLORS.DARK_TEXT[2]);
            
            // CORRECCIÓN: Se interpola el conteo de Cargadas
            doc.text(`PLATAFORMAS CARGADAS (${counts.Cargada})`, margin, startYDoubleColumn); 
            
            const xPosVacias = margin + halfWidth + tableMarginX;
            // CORRECCIÓN: Se interpola el conteo de Vacías
            doc.text(`PLATAFORMAS VACÍAS (${counts.Vacía})`, xPosVacias, startYDoubleColumn); 
            
            startYDoubleColumn += 5; 
            
            // Estilos de la Tabla (Apple Pages Look)
            const styles = { 
                fontSize: 9, 
                cellPadding: { top: 2, right: 3, bottom: 2, left: 3 }, 
                valign: 'middle', 
                font: "helvetica", 
                textColor: APPLE_COLORS.DARK_TEXT, 
                lineColor: APPLE_COLORS.MEDIUM_GRAY, 
                lineWidth: 0.05, 
                fontStyle: 'normal' 
            };
            
            const headStyles = { 
                fillColor: [249, 249, 249], 
                textColor: APPLE_COLORS.DARK_TEXT, 
                fontStyle: 'bold', 
                lineWidth: { top: 0, right: 0, bottom: 0.15, left: 0 }, 
                cellPadding: 3 
            };
            
            const alternateRowStyles = { 
                fillColor: [255, 255, 255] 
            };
            
            const tableOptions = {
                startY: startYDoubleColumn,
                styles: styles,
                headStyles: headStyles,
                alternateRowStyles: alternateRowStyles, 
                didParseCell: (data) => {
                    if (data.row.section === 'body') {
                        data.cell.styles.minCellHeight = 5;
                    }
                }
            };

            // --- Tabla de Cargadas ---
            doc.autoTable({
                head: [['MATRÍCULA', 'CONTENIDO']],
                body: registrosCargadas,
                margin: { left: margin, right: pageWidth - (margin + halfWidth) }, 
                tableWidth: halfWidth,
                columnStyles: {
                    0: { cellWidth: 25, fontStyle: 'bold', fillColor: [240, 255, 240], textColor: APPLE_COLORS.GREEN_CARGADA }, 
                    1: { cellWidth: 'auto' }
                },
                ...tableOptions
            });
            let finalYCargadas = doc.autoTable.previous.finalY;

            // --- Tabla de Vacías ---
            doc.autoTable({
                head: [['MATRÍCULA', 'DESCRIPCIÓN']],
                body: registrosVacías,
                margin: { left: xPosVacias, right: margin }, 
                tableWidth: halfWidth,
                columnStyles: {
                    0: { cellWidth: 25, fontStyle: 'bold', fillColor: [255, 255, 240], textColor: APPLE_COLORS.YELLOW_VACIA }, 
                    1: { cellWidth: 'auto' }
                },
                ...tableOptions
            });
            let finalYVacías = doc.autoTable.previous.finalY;

            let finalY = Math.max(finalYCargadas, finalYVacías); 
            
            // --- Tabla de Averíadas (Full Width) ---
            if (counts.Averiada > 0) {
                
                if (finalY + 20 > doc.internal.pageSize.height - margin) {
                    doc.addPage();
                    finalY = margin;
                } else {
                     finalY += 10; 
                }

                // Título de Sección Averiada
                doc.setFontSize(12);
                doc.setFont("helvetica", "bold");
                doc.setTextColor(APPLE_COLORS.DARK_TEXT[0], APPLE_COLORS.DARK_TEXT[1], APPLE_COLORS.DARK_TEXT[2]);
                // CORRECCIÓN: Se interpola el conteo de Averíadas
                doc.text(`PLATAFORMAS AVERIADAS (${counts.Averiada})`, margin, finalY + 5); 
                
                doc.autoTable({
                    head: [['MATRÍCULA', 'DESCRIPCIÓN DE AVERÍA']],
                    body: registrosAveriadas,
                    startY: finalY + 10,
                    margin: { left: margin, right: margin },
                    columnStyles: {
                        0: { cellWidth: 30, fontStyle: 'bold', fillColor: [255, 240, 240], textColor: APPLE_COLORS.RED_XPO }, 
                        1: { cellWidth: 'auto' }
                    },
                    ...tableOptions
                });
                finalY = doc.autoTable.previous.finalY;
            }

            // --- Pie de Página (Footer) ---
            const footerY = doc.internal.pageSize.height - 5;
            
            doc.setFontSize(8);
            doc.setTextColor(APPLE_COLORS.MEDIUM_GRAY[0], APPLE_COLORS.MEDIUM_GRAY[1], APPLE_COLORS.MEDIUM_GRAY[2]);
            doc.setFont("helvetica", "normal");
            
            const pageCount = doc.internal.getNumberOfPages();
            for(let i = 1; i <= pageCount; i++) {
                doc.setPage(i);
                
                // Texto de derechos de autor
                doc.text(`© ${new Date().getFullYear()} XPO LOGISTICS - Informe interno`, margin, footerY);
                
                // Conteo de Páginas
                // CORRECCIÓN: Se interpolan i y pageCount
                doc.text(`Página ${i} de ${pageCount}`, pageWidth - margin, footerY, { align: 'right' });
                
                // Línea divisoria sutil para el footer
                doc.setDrawColor(APPLE_COLORS.MEDIUM_GRAY[0], APPLE_COLORS.MEDIUM_GRAY[1], APPLE_COLORS.MEDIUM_GRAY[2]);
                doc.setLineWidth(0.1);
                doc.line(margin, footerY - 2, pageWidth - margin, footerY - 2);
                
                // Título del reporte e información de la fecha
                if (i === 1) {
                    const currentDay = new Date().toLocaleDateString('es-ES', { weekday: 'long' }).toUpperCase();
                    const currentDate = new Date().toLocaleDateString('es-ES', { day: '2-digit', month: 'long', year: 'numeric' }).toUpperCase();
                    
                    doc.setFont("helvetica", "normal");
                    doc.setFontSize(8);
                    doc.setTextColor(APPLE_COLORS.MEDIUM_GRAY[0], APPLE_COLORS.MEDIUM_GRAY[1], APPLE_COLORS.MEDIUM_GRAY[2]); 
                    // CORRECCIÓN: Se interpolan currentDay y currentDate
                    doc.text(`REPORTE EJECUTIVO DE FLOTA | ${currentDay}, ${currentDate}`, margin, headerCardY + headerCardHeight + margin - 2); 
                }
            }
            
            // Abrimos el PDF en una nueva pestaña
            doc.output('dataurlnewwindow', {filename: 'Reporte_XPO_Ejecutivo.pdf'});
            mostrarConfirmacion("PDF generado. Se ha abierto en una nueva pestaña (o la descarga ha comenzado).", "fas fa-file-pdf");

        } catch (e) {
            console.error("Error al generar PDF:", e);
            mostrarConfirmacion("Error al generar el PDF. Revisa la consola para más detalles.", "fas fa-exclamation-triangle");
        }
    }


    // --- LÓGICA DE ANIMACIÓN Y SCROLL ---
    function handleScroll() {
        const header = document.getElementById('fixedHeader');
        const scrollPosition = window.scrollY;
        
        if (scrollPosition > 10) {
            header.classList.add('scrolled');
        } else {
            header.classList.remove('scrolled');
        }
    }
    
    // --- Lógica de animación restaurada con localStorage ---
    function animarLogo() {
        const logoCode = document.getElementById('logoCode');
        const logoXPO = document.getElementById('logoXPO');

        // Resetear estilos iniciales (que son establecidos en CSS para la animación)
        logoCode.style.opacity = '0';
        logoXPO.style.opacity = '0';
        logoXPO.style.transform = 'translateY(20px)';
        
        // Comprobar si ya se animó antes (Persistencia con localStorage)
        if (!localStorage.getItem('logoAnimado')) {
             // Inicia animación si es la primera vez
             setTimeout(() => {
                logoCode.style.opacity = '1';
                logoCode.style.transform = 'translateY(0)';
             }, 50);

             setTimeout(() => {
                logoXPO.style.opacity = '1';
                logoXPO.style.transform = 'translateY(0)';
             }, 350); 
             
             localStorage.setItem('logoAnimado', 'true');
        } else {
            // Si ya se animó, mostrar inmediatamente sin animación
            logoCode.style.opacity = '1';
            logoCode.style.transform = 'translateY(0)';
            logoXPO.style.opacity = '1';
            logoXPO.style.transform = 'translateY(0)';
        }
    }

    // --- INICIALIZACIÓN GLOBAL ---
    document.addEventListener('DOMContentLoaded', () => {
        animarLogo();
        actualizarContadores();
        actualizarHistorialReciente(); 
        
        // El botón de paso 1 ya tiene un ID en el HTML.
        document.getElementById('btnExportar').addEventListener('click', exportarPDF);
        
        document.getElementById('paso1').style.display = 'block';
        document.getElementById('paso1').style.position = 'relative'; 
        document.getElementById('paso1').classList.add('active');
        document.getElementById('matriculaInput').focus();
        
        // --- ACTIVAR EL MANEJO DE SCROLL PARA EL EFECTO DINÁMICO ---
        window.addEventListener('scroll', handleScroll);
        handleScroll();

        // Asegurar que el filtro inicial sea 'Todo'
        document.getElementById('btnFilterAll').classList.add('filter-active');
    });
</script>